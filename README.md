# SBA-308A - AniGuesser, an anime character guessing game

This is a one-page web application called Anime Guesser that prompts the user to guess a random main character based off of their photo. The anime's main characters are gathered through an additional API call based on the current anime the user is viewing. The user can navigate through all of the main characters for a particular anime and make guesses. Each anime character has its own guess-related stats, so guesses from one anime character will not carry over to the next. This enables the user to backtrack and view their previous results. The user can randomize the anime and character by pressing the randomize button. At the moment, there is no logic to handle the edge case of receiving the same exact anime or even the same exact anime character. The user can also choose to give up on guessing and reveal the name of the anime character. The application is responsive and indicates which characters the user gave up, haven't figured out, or solved when going through the images. Upon successfully guessing or giving up on guessing the anime character, the user can get info on the character and read about it. All anime-related data is retrieved from the [Jikan Anime API v4](https://docs.api.jikan.moe/).

## Files

The project contains subdirectories of classes, constants, images, and scripts. Outside of the directory, it has a `styles.css` file, an `index.html` file, and this `README.md` file. The `index.html` file is very simple, but handles the core logic of the application. Without it, the game will not run at all.

### Classes Directory

In the classes folder, the `Game.js` file handles the game logic itself. It strictly contains a class, `Game`, which is used in `../scripts/index.js` to create one instance of the game. The `Overlay.js` file handles all logic related to the overlay. The `Settings.js` file handles all logic related to the game's settings. Both `Settings.js` and `Overlay.js` are used in `Game.js` to create one private instance of each in order for the game to function. The `User.js` file handles the logic for users that are playing the game (mostly used to store and access data related to the user). All of these classes are modules that have a default export of their respective class.

### Constants Directory

In the constants folder, the `constants.js` file contain important objects or arrays that must stay the same. Some of these constants are used to populate the overlays in `../classes/Overlay.js`, while other constants like `defaultSettings` are used as a constant to make a copy from. The `selectors.js` file contain all the selectors for static elements on the webpage. These selectors are referenced in most of the js files to prevent having to declare the selector each time.

### Images Directory

The images folder contains dark and light versions of the profile, results, and settings icons. These are used as background images so that the change in styling (from dark mode to light mode) changes these indirectly with Javascript (change in game settings).

### Scripts Directory

The scripts folder contains `apicalls.js`, `functions.js`, `index.js`, `login.js`, and `signup.js`. Explanations for the last three files can be found in the game logic section.

#### Making API Calls

The file `apicalls.js` handles making calls to the api using axios. There is a request and response interceptor used to log the time and duration for requests and responses. There are three different types of requests: `getAnimeList()`, `getAnimeCharacters(animeId)`, and `getAnimeCharacterFullInfo(characterId)`. These requests' id correspond to the MyAnimeList ids (referred to as mal_id in the data). The first request `getAnimeList()` only runs when the game starts. The anime-related info is stored in a private animeInfo object in `Game.js` and used to store most of the anime-related data from the API calls. This API call retrieves 25 TV anime with a minimum score of 8, ordered by favorites, sfw, and sorted in descending order. The API itself only allows a maximum of 25 anime to be retrieved at a time (any limit higher leads to an invalid call). At the moment, there isn't another API call to get more anime entries. This info is stored as the `info` key to the AnimeData entry of that particular animeId (the mal_id that references it). The second request `getAnimeCharacters(animeId)` retrieves all characters from a particular anime. The main characters are stored as the `mainChars` key to the AnimeData entry of that particular animeId. All characters are stored as the `allChars` key to the AnimeData entry matching a particular animeId. The third API call `getAnimeCharacterFullInfo(characterId)` is used to retrieve all info related to a specific anime character. This information is not stored and only used to populate the anime character info div in the overlay.

#### Functions

This file contains functions that are shared across modules and a couple of shared functions that could be in its own module, but haven't been separated yet. The functions that belong here are the event listeners for showing and hiding a description overlay (a tooltip for buttons and descriptions for settings). The event listeners `showDescription(e)` and `hideDescription(e)` perform their expected tasks by removing the `hidden` class and showing the `hidden` class, respectively. The rest of the functions, `getUsers()`, `getUser(username, password)`, `addUser(userObject)`, `propertyExists(property, value)`, and `clearUsers()`, are also used to access or modify the localStorage. These functions accomplish their expected tasks and are all used by `signup.js` and `login.js` (except for `clearUsers()`, which exists for testing purposes).

## Important Objects with Private Properties Examples from the Game and User Classes

This section contains a snippet of JDocs from the `Game.js` file. The types and private properties of the `Game` class will be mentioned throughout the Game Logic section.

```javascript
/**
 * Represents the object containing all information on an anime
 * @typedef {Object} AnimeData - Used in Game.js
 * @property {object} info - General info about the anime
 * @property {object[]} mainChars - An array of main characters
 * @property {object[]} allChars - An array of all characters
 */
// Private property animeInfo from the Game class
/**
* Store anime data in an object
* @type {Object.<number, AnimeData>}
*/
#animeInfo = {};

/**
 * Represents the object containing the answers for all anime main characters
 * @typedef {Object} AnimeAnswer - Used in Game.js
 * @property {Set<string>[]} answers - The array of sets that contain acceptable answers. The array index corresponds directly to the index of the character in animeInfo[animeId].mainChars[index]
 * @property {string} display - The correct answer to display when the user gives up or guesses successfully
 */
// Private property animeCharacterAnswers from the Game class
/**
* Store acceptable answers for each anime character in this obj. Each key corresponds to that anime's index in the array animeInfo[mal_id].mainChars.
* @type {Object.<number, AnimeAnswer}
*/
#animeCharacterAnswers = {};

/**
 * Represents the object containing a guess for a particular anime main character
 * @typedef {Object} UserGuess - Used in User.js and Used in function.js
 * @property {null | string} userAnswer - The valid guess provided by the user
 * @property {number} guessesTook - The number of guesses the user used (until they got the answer or gave up)
 * @property {boolean} gaveUp - The boolean that represents if the user gave up
 */
// Private property characterGuesses from the User class
/**
 * Represents the object containing the user's valid guess for all anime main characters
 * @type {Object.<number, UserGuess>}
 */
#characterGuesses;

/**
 * Represents the object containing the user's settings
 * @typedef {{"dark-mode": boolean, hints: boolean, blur: boolean, colors: boolean}} UserSettings - Used in function.js
 */

/**
 * Represents the object used to store information in the localStorage
 * @typedef {Object} UserObject - Used in function.js
 * @property {string} username - The username of a user
 * @property {string} email - The email address of a user
 * @property {string} password - The password of a user
 * @property {UserSettings} settings - The settings of a user
 * @property {Object.<number, UserGuess>} guesses - The anime character guesses of a user
 */
```

## Game Logic

This section explains how the game works and what happens behind the curtains from start to end. It will cover all the essential functions in `Game.js`, `Overlay.js`, `Settings.js`, `Slideshow.js`, and `User.js`. Make sure to read the previous section on important objects and properties before this section. The term animeId/anime id/mal_id all relate to the anime's particular id. The character index is the character's index in the array of main characters. The allChars object is not used yet, but will be used in future implementations to show popular supporting characters of an anime.

### Setting Up the Game

This anime character guessing game heavily relies on the `Game` class in `Game.js`. The file consists of various imports from other modules to handle api calls, shared methods, the slideshow, DOM selectors, and reference the overlay, settings, and user classes. The constructor for the Game class requires a user argument to bind the game to a particular user. To handle this, the `index.js` file declares an empty user with the default settings. The Game constructor also initializes the gameStarted property as false (since the game hasn't started yet), an instance for the slideshow, and instances for settings and overlay binded to the same user. The game has getters for the user and settings instance. The class also has a custom setter that is used to handle changing the user. This is only used in `login.js` and `signup.js` to change/update the user upon successfully logging in or signing up. The setter also updates the user for the overlay and settings instances. The login/sign up div is hidden and the logout/profile div is shown (this shows that the user is logged in).

### User Class

This section explains the main functionaity of the `User` class. The class has two private methods `#animeExists(animeId)` and `#animeCharExists(animeId, Index)` which check if an anime with animeId exists in the user's character guesses and if an anime character with animeId and index exists in the user's character guesses, respectively. The rest of the methods are public. The `hasAnswer(animeId, index)` method checks if the user's answer for an anime character exists (if they gave a valid answer for a particular anime character). Since answers are initialized as null, the value of the user's answer is compared to it. The `storeAnswer(animeId, index, answer)` function stores the valid guess of a user for a particular anime's main character. The `giveUp(animeId, index)` method is used when the user gives up on guessing the anime character. It only allows giving up if the user hasn't guessed the character and if they haven't given up yet. The `gaveUp(animeId, index)` method returns whether the user gave up on guessing the anime character. The public method `incrementGuess(animeId, index)` increments the guess count for a particular anime character. It will only increment the guess count for an anime character if the user hasn't found the answer yet and they haven't given up yet. The `getSolvedCount(animeId)` method returns number of anime characters solved guessed for that anime if the anime exists. Otherwise, it returns -1. The `getGuessCount(animeId, index)` method the guess count of an anime's main character if they exist. Otherwise it returns -1. The `toggleSetting(setting)` method toggles the specific user setting. It only accepts the options "dark-mode", "hints", "blur", or "colors". The `initGuessesOfAnime(animeId)` initializes each animeId key's value as an empty array if it is undefined through the use of the or operator. Lastly, the `initCharGuessesOfAnime(animeId, numChars)` method updates characterGuesses by initializing the object representing the user's guess for the character with UserGuess objects and pushes it to the array at characterGuesses[animeIndex].

### Starting the Game

After initializing a user and game instance in `index.js`, the game can be started through the `startGame()` method. This method is async since it fetches 25 anime using the `getAnimeList()` method from `apicalls.js`. The method needs to block until the list of anime is received. After that, the method initializes the anime selector using the private `#initSelector()` method to iterate through the anime list. The method appends option elements with id and value corresponding to the anime's mal_id and the title of the anime as text content to a document fragment. The english is shown if the anime has one, otherwise it shows the title (which is sometimes the English-phonetic version of the Japanese title pertaining to the anime). creates the general structure for character answers, stores anime data. Once all options are added, the fragment is appended as a child element to the anime selector. Next, the private `#initGameData()` method is used to initialize/store game data by iterating through the anime list. It creates the general structure for each anime info entry as an AnimeData object and stores the anime's data in the key `info`. At the moment, the data is stored as is, but it should be filtered so that less memory is used. The other two keys, mainChars and allChars, are set to null. These keys will be updated in another private method, `#generateAnswers(animeId)`. The `#initGameData()` method also declares each key in `#animeCharacterAnswers` to the value of an empty array. The private `initUserData()` method iterates through each of the anime id keys in the anime info object to initialize the character guesses for each anime by calling the user's public method `initGuessesOfAnime(animeId)`.
initializing event listeners, and creating the general structure for the user's guesses. Next, the method sets up the event listeners on the webpage for static elements using the private method `#setUpEventListeners()`. More information on the event listeners in the next section. After that, the private method `#chooseAnime(animeId?)` which has an optional argument animeId is called. As of this moment, anytime this private method is called, no argument is passed, so the default argument is a random animeId chosen from the private method `#chooseRandomAnime()`. That private method accesses the keys of the `animeInfo` private object and returns a random key from it. This public method, `startGame()` can only run once (the `#gameStarted` private property is set to true after successfully running).

### Setting Up Event Listeners for Static HTMLElements

The private method `#setUpEventListeners()` adds event listeners to the game-related buttons and the anime selector. The randomizeButton, giveUpButton, and getInfoButton will each contain three event listeners: "click", "mouseover", and "mouseout". The last two events handle showing and hiding the button tooltip (`showDescription(e)` and `hideDescription(e)` respectively from `functions.js`). The randomizeButton's click event listener is binded to the game's private method `this.#chooseAnime()`. The giveUpButton's click event is binded to the game's private method `this.#handleGiveUp()` which handles the user giving up on guessing the character. The getInfoButton's click event is binded to the game's private method `this.#getCharacterInfo()` which handles showing the information of a particular anime character. The animeSelector's "change" event is binded to the the game's private method `this.#chooseAnime(e.target.value)`. The guessButton's "click" event is binded to the game's private method `this.#checkAnswers(e)`, which checks if the user's guess is correct. The signOutAnchor's "click" event is binded to the game's private method of `this.#signout()` which handles signing out.

### Choosing an Anime and Guess Validation

The private method `this.#chooseAnime()` handles choosing a random anime and a random main character from that anime. First, it disables all game related buttons (guess, randomize, giveup, and info) to prevent the user from doing anything else while the anime is being chosen. Next, it updates the selector to show which anime the character is from. After that, the game attempts to access the main characters from the animeInfo object. If it doesn't exist, it will make the API call to fetch all characters which will retrieve the info and store it. Once this part is complete, it checks if the user's anime character guesses object is initialized for that particular animeId and initializes it if needed. Then, the method will attempt to generate all acceptable answers with `this.#generateAnswers()` for the anime if the answers have not been generated yet. Answers are stored as lowercase because the guess should not be case sensitive. If nicknames are provided (some characters have nicknames, while others do not), the lowercase version of the nicknames are added to the set of acceptable answers. The two base cases for the anime character's name are "name the title" and "last name, first name". For the first case, only the original full name and the first name are acceptable. The last case allows inputting "first name last name", "first name, last name", "last name first name", and "lastname, firstname". Sometimes an anime character has a really long last name (middle names with last names), so these are treated as last names also. For names like "Middle Last, First" the "Last First" and "Last, First" entries will also be acceptable. The animeCharacterAnswers object is updated by pushing the object of answers: {the acceptable answer set of strings} and display: the answer as a string which should be displayed to the user when they correctly guess the character or gave up. After everything is complete, the 4 game buttons are enabled again. The event listener `#checkAnswer(e)` handles this by accessing the target's value (the target is always the input field) and checks if the user's guess is in the set of acceptable answers. If the user guess is empty, immediately return. The function increments the guess count if the answer is not an empty string and performs these checks. An alert is shown in the slideshow container that informs the user about their guess using the `#createAlert(reason, classList)` private method. If the guess is empty or wrong, an error message with a red background appears. If the answer is correct, an alert with a green background appears and the user's answer is stored in their respect object through `this.#user.store(animeId, formatted answer)`. The answer is formatted by proper case using the private method `#formatAnswer(answer)` and the `#upper(name)` private method. The `#upper(name)` method also properly handles roman numerals up until 11 (capitalizes all letters). The form is reset, the stats are updated, and all settings are reloaded to update the level of blur (depending on user settings) in relation to hints and blur.

### Anime Character Slideshow

The class Slideshow handles all functionality for the anime slide show. The class contains a private property `#currentPicIndex` which indicates the index of the current photo being shown. The constructor initializes the current slide index as 1 and sets up the event listener (using `#setUpEventListeners()`) for the static elements (next and prev) which are the anchor elements that handle viewing the next and previous photo. Initializing the index is not necessary in the context of the game (since its public method is used to create the slideshow, which by default sets this as 1 or the provided index). The class contains the private methods `#clear()`, which clears the slideshow container and dotNavigation container, `#hidePicsAndDots()`, which adds the hidden class to all dots and photos, `#showPic(num)`, which shows a particular picture at the given position, and `#buttonNavigate(num)`, which increments or decrements the currentPicIndex. The public method, `createSlideShow(animeInfo, index=1)`, handles most of the core logic. This function takes two parameters, animeInfo (the AnimeData object) and index (the index of the anime character that should be shown). The index parameter is optional (defaults to 1 if none is provided so that the first character of the anime is shown). Two fragments are created (one for the slideshow container and the other is for the dot navigation container) to append the respective elements to each fragment, then appending that fragment to the respective container. The slideshow container will have X anime img-containers (where X represents the number of main characters the anime has) and the dot naviagation container will have X dots. Each dot will have its own click event listener which handles showing that particular anime character when clicking on the dot. After all this is complete, the function `#showPic(this.#currentPicIndex)` is called to show the current picture. This private method ensures that the currentPicIndex is within the range of 1 to X (X = number of anime characters), inclusively. Then, it hides all the pictures and removes the selected class from the dots (through `#hidePicsAndDots()`) and removes the hidden class from the index of the photo being shown (minus 1) and adds the selected css class to the respective dot of the same index (minus 1 also). Towards the end of the method, the gaveUp and solved css classes are removed from the answerDiv to reset the styling before showing the next photo. This prevents having both solved and gaveUp styling when the user correctly guesses or gives up, respectively. Lastly, it calls `game.updateStats()` to update the stats of the game (informs the game that the guess count and related data should be updated to reflect the particular anime character).

### Updating Stats and Game States

The public method from `Game.js`, `updateStats()`, is used to update the state of the game as well as the user's stats. It will update the guess counter, number of anime characters guessed / total anime characters for that anime, the input container, and the game buttons div based on the three states of the game. The three game states are guessing, guessed, and gave up. If the user is still guessing, the answerDiv and getInfoButton remain hidden while the giveUpButton remains visible. Otherwise, if the user gave up or guessed the character correctly, the answerDiv is shown. A character that was guessed has a green background, while a character that the user gave up on has a red background. The photo itself is not being colored, this is just the background color for the div with the answer. The guess state is handled through the helper function `updateGuessState(answer, user)`. After the guess state is updated, the user data is saved. The methods `#checkAnswers(e)` and `#handleGiveUp()` change the game state. Checking the answers displays any alerts based on the user's guess and calls `updateStats()` to update the stats and game state. Pressing the give up button triggers the `#handleGiveUp()` method which informs the game that the user gave up and handles the game state accordingly. As mentioned earlier, the User class contains public methods that allow the game to manipulate the object of anime character guesses along with safeguards to prevent updating data that shouldn't be changed anymore or does not exist. Entering a guess and checking it resets the form and reapplies all settings (to handle the proper intensity of blur and image colors).

### Creating the Overlay

The `Overlay` class is stored in the `Overlay.js` file and handles all actions related to the overlay. It contains two private properties, `#user` and `#settings`. It is binded to the same Settings and User instance declared in the game instance. There is a setter for the user which is used when logging in, signing up, or signing out. The constructor binds the user and settings passed as arguments, then initializes event listeners for static elements that use methods from the overlay class. The settingsBtn, instructionsBtn, navLoginSignUpDiv, and overlayDiv are binded to "click" events. The settingsBtn and instructionsBtn are binded to the public method `show(type, data?)` with arguments of "settings" and "instructions" respectively. The login signup div in the navbar is binded to the private event listener `#openLoginSignUp(e)` which shows the login or signup form depending on the lowercase version of event target's textContent with whitespace removed. This filtered version of the textContent is passed as an argument to the public `show(type, data?)` method. This method handles showing the character info, login/sign up form, settings, or instructions which call private methods `#createCharacterInfo(characterInfo)`, `#createForm(type)`, `#createSettings()`, and `#createInstructions()` respectively. All content displayed for the settings, forms, character, and instructions are created by appending elements to a document fragment. Since the contents of the instructions are static, no deeper explanation will be provided for this method. The overlay is closed by clicking anywhere outside of the element with content stored in it (clicking on the overlay div itself). This is accomplished through user interaction (the event listener `#closeOverlay(e)`) or programmatically calling the public function close(). Both functions accomplish the same task, but the latter is used to handle closing forms upon successful login or sign up. Both methods clear the overlay div through the private function `#clear()`, which removes the first element child of overlay div (since this div will only ever have one child element at a time).

### Showing Character Info

An anime character's information can only be shown after guessing the character or giving up. Once the info button is pressed, an API call fetches all information pertaining to the current anime character and displays the kanji, Japanese Voice Actors, English Voice Actors, image of the character, and general information about the character. The about data is not directly formatted because the structure varies for each character. A scroll bar is present if there is a lot of information about the character. It is stored in a pre element to maintain the content styling.

### Handling User Settings

The user's settings are handled through the `Settings` class in the `Settings.js` file. The class has a private property, `#users` which is binded when calling the constructor. The instance accesses the user's settings and toggles values based on user interaction with the settings overlay. In the overlay's `#createSettings()` method, event listeners are added while creating each user setting. The `showDescription(e)` and `hideDescription(e)` event handlers are added to each setting name to provide a brief description of the setting. The button for toggling on and off the setting is a visual representation of the user's settings. The overlay needs to be binded to the settings instance so that it can handle changing a setting (the anonymous click event listener is added to each optionBtn to accomplish this). The public method from the `Settings` class, `changeSetting(setting)`, is used to toggle the user's settings behind the scenes. Toggling the classlist "on" for the button in the `Overlay` class and its parent element applies the setting change visually.

### Logging In and Signing Up

Logging in and signing up is handled by both the overlay and the respective `login.js` and `script.js` files. The overlay is responsible for adding particular event listeners, while the other two files handle the actual validation logic. The login and signup forms have the submit event binded to `handleLogin(e)` and `handleSignUp(e)` respectively. Each input element contains two event listeners. For both forms, all inputs have a temporary anonymous event listener that happens once and are binded to the event "blur". This event listener prevents showing the invalid border from built-in form validation when the form is in its initial state. The red border for invalid fields only show up after entering and leaving the field for the first time, hence the third parameter { once: true }, which fires the event listener once. For the login inputs, the validity of the fields are handled through the event "change" (only when the user is done changing the field) and calls the function `validateLogin(e)` from `login.js`. If the target's name is username, it validates if the username exists in localStorage. If the target's name is password, it checks if the username exists and updates the validity of username if it does exist. Otherwise, it checks if the username and password pair exists in localStorage. This is the expected behavior because there is no reason to perform a password check if the username doesn't exist to begin with. If validation is a success, set the validity of the particular input to an empty string. The sign up form's event listeners are similar, but use different logic for validity. The username input uses the `validateSignUpUsername(e)` event listener which ensures that usernames do not contain special characters or whitespace, are at least 6 characters long, and aren't already taken. The email input uses the `validateEmail(e)` event listener which ensure that the email is not taken and matches the format of an email. The password input uses the `validateSignUpPassword(e)` event listener to verify that the password is at least 10 characters long, contains at least one special character, does not contain the word password, and matches the confirmPassword input. The confirmPassword input uses the `validateBothPasswords(e)` event listener to verify that both password are the same. Any change in validity is reported to the password field. The length for password and username are verified using the built-in validation. The format of an email address is verified using built-in validation. A valid login or signup resets the form, accesses localStorage, and closes the overlay. A valid login retrieves the specific user data, creates a new instance of the User with the stored username, email, settings, and guesses, and replaces the game's user instance. A valid sign in adds the user as an object to the localStorage, creates a new User instance with the username and email from the form and the settings and guesses from the current user. Then, it updates the user instance of the game by replacing it. This replacement triggers showing the sign out anchor and a standard user profile icon to the left of it. Pressing signout will save the user's data and sign them out. It will create a new blank user instance with default settings and no guessed progress.

### User Data Persistence

The functions `getUsers()`, `getUser(username, password)`, `addUser(userObject)`, and `propertyExists(property, value)` from `function.js` are used to interact with the localStorage. The array of UserObjects are stored under the key "users". The function `getUsers()` initializes the users item in localStorage if it does not exist. It returns the array of UserObjects (conversion from JSON to array already takes place). The `getUser(username, password)` function returns the user with the matching (user, password) pair. The `addUser(userObject)` method is used to add a particular user (when signing up was successful) to the the array of UserObjects stored in localStorage. Lastly, `propertyExists(property, value)` is used to verify if a particular property (username, email, etc.) already exists in the array of UserObjects. As mentioned earlier, the user's guesses and settings are the only objects being updated when the game is saved. Saving only occurs when signing out, making a guess, or changing a setting. In a future implemention the setInterval function might be used to handle saving in intervals.

### Final Thoughts

The project was fun to implement and went through many revisions. Although not all functions are completely organized (localStorage access is not set up in a more protective way), the core functionality is wrapped in classes and proper files. A different route was chosen for this login and signup validation (leveraging the built in validation and adding onto it). More research must be conducted to refine the form validation. In future revisions, the data stored will be filtered to use less memory (not all anime info and character info is used).